
****************************************************************
****************************************************************
****************************************************************

      SURF-HIPPO INTEGRATION - NUMERICAL METHODS

****************************************************************
****************************************************************
****************************************************************



-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

			Table of Contents

1. Simulator Representation of Circuit Structure
2. Integration of the Circuit
3a. Determination of Time Step
3b. Break Points
4. Time Step Global Variables
5. Particle Errors
6. Voltage Errors
7. LTE Estimation
8. Shadowing Time Steps From a Previous Simulation
9. Ordering the Matrix
10. Solving the Circuit
11. How The Code Does It, Briefly
12. Ideal Voltage Sources

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

****************************************************************
****************************************************************

	 Simulator Representation of Circuit Structure

****************************************************************
****************************************************************

Symbolically, circuits are composed of a set of object instances, of
which there are several different types: nodes, segments, somata,
channels, synapses, isources, particles, concentration integrators,
etc. There are many different interrelationships between objects in a
hierarchical fashion, e.g. an instance of a channel object references
an instance of a node object (corresponding to the electrical circuit
node that it is attached to), an instance of a segment or soma object
that it is a part of, instances of particle and/or concentration
particle objects that determine the channel's conductance, and,
indirectly, instances of particle nodes which correspond to the
particles' states.

Simulation of circuits is in terms of their nodes, which include the
actual electrical nodes (corresponding to somata and segments) as well
as elements whose states are both dependent on other nodes and in turn
control either branch elements of the circuit or other (non-voltage)
nodes. This latter class of elements include the following:

 * Element *            * State *               * Dependent On *         * Controls *

 V-dep particles   Prob[open state] (0-1)        Segment/soma voltage   Channel conductance
 Ca-dep particles  Prob[open state] (0-1)     Concentration Integrator  Channel conductance
 Conc Integrator   [X] in Shells (mM)      Some current in soma or segment  Conc-dep particles

The voltages and states of the above elements correspond to the state
variables of the circuit. 


****************************************************************
****************************************************************

		   Integration of the Circuit

****************************************************************
****************************************************************

For integrating the circuit equations, Surf-Hippo uses a variant of
the method described by Hines, "Efficient computation of branched
nerve equations" Int. J. Bio-Medical Computing (15) (1984) p69-76.
Briefly, the method splits each time step into an implicit and
explicit phase, and is equivalent to the Crank-Nicholson method. A
major difference between the method described in this reference, and
the Surf-Hippo method, is that Surf-Hippo uses a variable time step,
whose size is adjusted during the integration by an estimate of the
linear truncation error.

Functions which are particularly important for the integration
discussed here are defined in the following files:

	src/sys/sim.lisp

	   Of particular interest: 
 
		PICK-TIME-STEP
		DO-TIME-CONTROL
		CHECK-TIME-STEP

	src/sys/calc-lte-ratio.lisp

	   Of particular interest: 

		CALC-LTE-RATIO

	src/sys/hines.lisp

	   Of particular interest: 
 
		HINES-SOLVE
		TRIANG
		BKSUB

	src/sys/particle.lisp

	   Of particular interest: 

		EVAL-PARTICLE


See also the channel.doc file.


****************************************************************
****************************************************************

		   Determination of Time Step

****************************************************************
****************************************************************

There are three methods for determining the time steps:

	1. Variable (choose step based on a LTE criteria)

	2. Fixed (constant time step is chosen before the simulation)

	3. Shadow (time steps are taken from a list of time steps
	   generated by an earlier simulation)
	

The shadowing method is used if the global variable *USE-TIME-LIST*
(default nil) is set and there are stored time steps which are valid
for the current simulation (e.g. the stop times match). See the
section Shadowing Time Steps From a Previous Simulation.

Otherwise, if *USE-FIXED-STEP* is set (default nil) then time step is
fixed with the value set by *USER-STEP* (in milliseconds).

Otherwise, the default behavior is an adaptive time step, where the
step is adjusted according to an estimate of the linear truncation
error (LTE). The main parameters that control the mapping between LTE
and the next time step include:

	*ABSOLUTE-VOLTAGE-ERROR* -> A reasonable range is 0.01 - 0.1
	*RELATIVE-PARTICLE-ERROR* -> A reasonable range is 0.001 - 0.01
	USER-MIN-STEP -> Can typically be set to 0.0 without danger [ms].
	USER-MAX-STEP -> A reasonable ragne is 0.5 - 5.0, which avoids
			 skipping over input events [ms].

These global variables may be set via "Overall Parameters, Load
Circuit or Archive" menu -> "Edit Simulator Global Variables" menu ->
"Time Step and Numerical Integration Parameters".

The adaptive time step is discussed further in the sections Particle
Errors, Voltage Errors, and LTE Estimation.


****************************************************************
****************************************************************

		Break Points

****************************************************************
****************************************************************

Break points are times for which the simulation is forced to use (for
variable time steps only). In general a break point is chosen because
there is a priori knowledge of some input which begins or changes
abruptly at that time. This makes less work for the adaptive time
step, since without this information the initial stepping would more
than likely enounter the input sometime after its initiation, and thus
may be forced to backup if the input was too large at the first
attempted time point that "saw" the input or the change in the input.
The result (in general) with using break points then is fewer overall
iterations and a solution that is less likely to have "ringing".

Float or integer break point times are collected prior to the
simulation onto the global variable *BREAKPOINT-LIST* (the
PICK-TIME-STEP function uses a version of this information in
*MRT-BREAKPOINT-LIST*) with the following functions (in init.lisp):

	queue-time TIME

TIME is a break point time in ms.

	queue-times TIMES

TIMES is a list of break point times in ms. 

	queue-breakpoints VALUE-ARRAY PERIOD DELAY

This is used for PWL (pulse-based) current and voltage sources.

In addition to break points added for any pulse-based source, break
points are added (automatically) for the onsets of any autonomous
processes, such as autonomous synapses.

Break points are collected automatically. If there are additional
break points desired, then they must be put into the global variable
*USER-BREAKPOINT-LIST*. *USER-BREAKPOINT-LIST* is cleared whenever
a brand new circuit is read in. For example,


	(push 15.0 *USER-BREAKPOINT-LIST*)

adds the time 15.0 ms to the break points used by the next
integration.


****************************************************************
****************************************************************

	    Time Step Global Variables

****************************************************************
****************************************************************



Note: To avoid consing, the single and double float globals which
track the time steps are stored in arrays (see declare.lisp):

  (defvar *time-single-float-variables* (make-array '(10) :element-type 'single-float))
  (defvar *time-double-float-variables* (make-array '(10) :element-type 'double-float))

For example:
  (defmacro *real-time* ()
    `(aref (the (simple-array single-float *) *time-single-float-variables*) 0))

Thus, the value for *REAL-TIME* is referenced as (*REAL-TIME*) in
the code. This may not be much of a win. 

During the integration, time is in units of the global variable MRT,
or the Minimum Resolvable Time. This is done so that internally time
may be kept as an integer; thus the value for MRT is used to convert
floating times into integers. We should note that the original
justification for the integer representation of time had to do with
implementation in *LISP and concerns about truncation error, and it is
not clear that there is a distinct advantage in the present code. 

MRT is set at the beginning of the simulation:

  (setf MRT (/ (float (max (abs USER-START-TIME) (abs USER-STOP-TIME))) MAX-INTEGER-TIME))

Note that USER-START-TIME is almost always equal to 0.

The constant MAX-INTEGER-TIME is set as:

   (defconstant MAX-INTEGER-TIME (expt 2 (- TIME-WORD-LENGTH 2)))

and is the maximum integer used for internal times. From the original
notes from Don Webber:

   "The word length is subtracted by 2, one to allow for 2's
    complement math, and one for safety if a simulation runs 
    over the stop time. I don't know if the second one is 
    necessary."

Likewise, the constant TIME-WORD-LENGTH is defined as the number of
bits in a integer used for internal times:

  (defconstant TIME-WORD-LENGTH #-cmu 32 #+cmu 28)

This was also inherited from Webber's SURF package. This value is not
guarranteed to be correct for all platforms. The +cmu figure of 28 was
estimated by finding the type-of 2^N, and N=28 was the largest value
that gave a FIXNUM.

Now, we shall review the remaining global variables which are relevant
to the time step. In general, only variables that include "USER"
should be set by the user.


 USER-START-TIME (default = 0.0), is the start time of the simulation,
 in milliseconds.

 START-TIME (default = 0), is the start time in units of MRT.

 USER-STOP-TIME is the time to end the simulation, in milliseconds.

 INT-USER-STOP-TIME is the integer part of the time to end the
 simulation, in milliseconds.

 STOP-TIME is the stop time in units of MRT.

 USER-MAX-STEP is the maximum time step allowed, in milliseconds. When 0,
 then MAX-STEP is bound by the simulation duration.

 MAX-STEP is the maximum time step in units of MRT.

 USER-MIN-STEP is the minimum time step allowed, in milliseconds. When 0,
 then MIN-STEP is set to *MIN-STEP-MRTS.

 MIN-STEP is the minimum time step in units of MRT.

 SIM-TIME-N+1 is the time for the step currently being computed, in
 units of MRT, i.e. t(n+1).

 SIM-TIME-N is the time for the step already computed, in
 units of MRT, i.e. t(n).

 SIM-TIME-N-1 is the time for one step back, in units of MRT, i.e. t(n-1).

 SIM-TIME-N-2 is the time for two steps back, in units of MRT, i.e. t(n-2).

 TIME-STEP is the current time step, in units of MRT.

 LAST-TIME-STEP is the last time step, in units of MRT.

 *REAL-TIME* is the time during simulation (msec), that is the end of
 the time step (corresponding to the prediction time of the data)

 *LAST-REAL-TIME is the value of *REAL-TIME* for the last time step.
 This value is used for, among others, axons and voltage dependent
 synapases who reference node voltages at the previous time step.


 *INPUT-TIME is the time reference for inputs (msec).

 When the flag *EVALUATE-INPUTS-AT-MIDPOINT* is true, at each time
 step the circuit inputs (e.g. sources, driven synapses) are evaluated
 at the midpoint of the step - otherwise, the inputs are evaluated for
 the end of the step (the prediction time).

 *INTEGER-TIME is the integer part (floor) of real-time (msec).

 *FRACTIONAL-TIME is the fractional part of real-time (msec).

 *USER-TIME-STEP* is in units of MRT.


These variables are used in the particle evaluations, since both the
current time step and the last one have to be considered:

 *DELTA-BACK* = (* 0.5 MRT LAST-TIME-STEP)

 *DELTA-FORWARD* = (* 0.5 MRT TIME-STEP)

 *REAL-TIME-STEP* = (+ *DELTA-FORWARD* *DELTA-FORWARD*)

 *REAL-TIME-STEP-SQUARED* = (* *REAL-TIME-STEP* *REAL-TIME-STEP*)

 *HALF-DELTA-FOR-BACK* = (* 0.5 (- *DELTA-FORWARD* *DELTA-BACK*))

 *SUM-DELTA-FOR-BACK* = (+ *DELTA-FORWARD* *DELTA-BACK*)

 *HALF-SUM-DELTA-FOR-BACK* = (* 0.5 (+ *DELTA-FORWARD* *DELTA-BACK*))



****************************************************************
****************************************************************

			Particle Errors

****************************************************************
****************************************************************


The functions PARTICLE-ERROR-OK (if *CONSIDER-PARTICLE-ERROR* is T)
and CALC-LTE-RATIO calculate the LTE from the gating particles and
node voltages, respectively.

When *CONSIDER-PARTICLE-ERROR* is T, prior to the evaluation of the
gating particles (both voltage and concentration dependent) the
variable *MAXIMUM-PARTICLE-ERROR-NUMERATOR* is set to 0. As each
particle is evaluated, *MAXIMUM-PARTICLE-ERROR-NUMERATOR* is set to
the numerator of the 2nd order LTE (a difference between the current
and last first derivatives of the particle state) when this value
exceeds the current value of *MAXIMUM-PARTICLE-ERROR-NUMERATOR*. When
all the gating particles have been evaluated, the value of
*MAXIMUM-PARTICLE-ERROR-NUMERATOR* is used to estimate the LTE. The
result is then used to calculate *PARTICLE-ERROR-MAX-TIME-STEP* (in
units of MRT). If this value is greater than the current time step, a
flag in DO-TIME-CONTROL (HINES-STEP-OK) is set to NIL.

****************************************************************
****************************************************************

			Voltage Errors

****************************************************************
****************************************************************


After the node voltages have been computed, CALC-LTE-RATIO returns the
ratio of the allowed error (*ABSOLUTE-VOLTAGE-ERROR*) divided by the
estimate of max error. Note that in the equations below there are
occasional references to the node structure slots that hold certain
variables.

At any given time during the simulation, the node with the largest error
must be one that has some input associated with it, e.g. a source, channel,
or synapse. All other nodes are driven by their neighboring nodes, and
since the capacitance of each node is non-zero, then the response of a node
driven by the voltage of a neighbor will always be slower than the
neighbor's voltage. Therefore, for estimating the maximum LTE, we need only
consider nodes with inputs.

Thus at the beginning of the simulation the function
MAKE-NODE-W/ELEMENTS-ARRAY sets the global array
*NODE-W/ELEMENTS-ARRAY* to point to all nodes with active (e.g.
gbar>0) membrane elements. It is these node that are considered in
estimating the maximum LTE in CALC-LTE-RATIO. Note that CALC-LTE-RATIO
also updates the voltage derivative, which is used for the particle
evaluation. Since all nodes with particles (channels) are included in
*NODE-W/ELEMENTS-ARRAY*, then these derivatives will be available for
the proper nodes.

The inclusion of all nodes with sources may be modified if the global variable
*INCLUDE-VSOURCE-NODES-IN-NODE-ERROR-EST* (default nil) is nil. In this case, if
there is more than one node in the circuit the node with the voltage source is
*not* included in the error estimation. This can avoid very small steps due to a
fast voltage source. In practice, this can greatly speed up the simulations
without effecting the result. However, it is a good idea to verify the simulation
results by an occasional run with any voltage source node included in the error
estimation. It is also a good idea to include any voltage source nodes in the
error estimation if the source impedance is large.


****************************************************************
****************************************************************

			LTE Estimation

****************************************************************
****************************************************************

Loop over the circuit nodes to be considered in the error estimate,
finding the largest estimated O(dt^2) error using the following
estimate for the second derivative of the voltage:

	V''(t + dt/2) = 0.5 [V'(t + dt) - V'(t)]  


	Let ND point to a circuit node:

	V'(t + dt) {(NODE-DVDT-N ND)} = 

			(NODE-VOLTAGE-N+1 ND) - (NODE-VOLTAGE-N ND)
			-------------------------------------------
				      time-step


	V'(t) {(NODE-DVDT-N-1 ND)} has been stored at the beginning of the time step from V'(t + dt)


	Maximize |V'(t + dt) - V'(t)| over nodes, put result into MAX-ERROR 


	Calculate error ratio:

				    *ABSOLUTE-VOLTAGE-ERROR*
	LTE-RATIO =	------------------------------------------------
				max-dv-diff * time-step * time-step
				----------------------------------
				(* 2 (+ last-time-step time-step))


If either the voltage LTE-RATIO is less than 1, or if the particle
error to too large (HINES-STEP-OK is NIL) then we redo the last time
step. Thus PICK-TIME-STEP will get as its CURRENT-TIME argument:

	SIM-TIME-N+1  (Last step successful)
 or
	SIM-TIME-N    (Last step unsuccessful)

This argument is needed so that PICK-TIME-STEP can check for special
time points (e.g. breakpoints) and other conditions which constrain what
the next time step can be. The basic calculation by PICK-TIME-STEP is
derived from the second order term in the Taylor expansion of the
voltage:

  NEW-TIME-STEP = PREV-STEP * (expt LTE-RATIO 0.5) * *PICK-TIME-STEP-FUDGE

If we are considering particle error, then NEW-TIME-STEP will then be
limited by *PARTICLE-ERROR-MAX-TIME-STEP*. Note that
*PARTICLE-ERROR-MAX-TIME-STEP* was calculated in PARTICLE-ERROR-OK by
essentially the same formula as above.

For non-linear circuits the fudge factor (typically 0.95) helps ensure
that a reduced time step (when LTE-RATIO is less than but close to 1)
is small enough so that the next try (iteration) yields new LTEs that
are within the error criteria. This is because the LTE for a
non-linear circuit is not proportional to the time step, and thus the
new step may not be small enough. In practice, this is a problem with
voltage-dependent channels.

*PICK-TIME-STEP-FUDGE must be less than or equal to 1.  As an
indication that *PICK-TIME-STEP-FUDGE is not small enough, check the
"Total time points/iterations" figure at the end of a simulation.  If
the LTE time step estimation is working properly, there should be no
more than one (extra) iteration per time point. Typically, of course,
there should be many time points in which the initial time step is
fine, and in fact is increased for the next time point. But as a
general rule of thumb, if the number of iterations is more than twice
the total time points, then a possiblility is that
*PICK-TIME-STEP-FUDGE is too large.

For more detailed tracing of the time step iterations, try watching
the evolution of the simulation with the *DEBUG-TIME-TRACE* flag
enabled (e.g. via "Overall Parameters, Load Circuit or Archive" menu
-> "Edit Simulator Global Variables" menu -> "Debugging Parameters")




The circuit matrix integration and the particle state integrations
described below take into account the variable time step, which is an
extension of the method described by Hines 1984.

The USER-MAX-STEP constraint may be overruled by the evaluation of
some element types, in particular those that are driven by an a-priori
(external) waveform. In these cases, the global variable
*ELEMENT-TIME-STEP-MAXIMUM* is set to a non-NIL step value (in units
of mrt) that matches the (smallest) time interval of the waveform(s).
For example, if EVAL-AXON finds itself in a spike, then the following
form is evaluated:

	(if (or (and *ELEMENT-TIME-STEP-MAXIMUM*
		     (> *ELEMENT-TIME-STEP-MAXIMUM* waveform-interval))
            	(not *ELEMENT-TIME-STEP-MAXIMUM*))
            (setf *ELEMENT-TIME-STEP-MAXIMUM* waveform-interval))

At the beginning of every time step, *ELEMENT-TIME-STEP-MAXIMUM* is
set to NIL. This mechanism ensures that the complete detail of an
applied waveform is captured by the simulation.


There are two lower limits on the internal (integer) time step -
USER-MIN-STEP (in units of ms, when not set to 0) and 2. When the LTE
estimate is too large despite using the minimum step, if

	 *PUNT-LTE-WHEN-MIN-STEP-REACHED* = T

then the simulation will keep going anyway, and the *LTE-WAS-PUNTED*
flag will be set. Otherwise, the simulation will stop and a message
will appear, e.g. (if USER-MIN-STEP = 0):
			      
	Integration stuck at time 4.353ms [internal integer time step = 2]. 
        Try either increasing the error criteria *ABSOLUTE-VOLTAGE-ERROR*, which is now 0.001,
	or reducing the simulation duration.

Or, (if USER-MIN-STEP is not = 0):

        Integration stuck at 4.353ms, try reducing USER-MIN-STEP, which now is 0.1ms.


Note that the lower limit of 2 is imposed because the evaluation at
each time step is done in two stages (which split the time step into
two).




****************************************************************
****************************************************************

	Shadowing Time Steps From a Previous Simulation

****************************************************************
****************************************************************

At the end of every simulation, the time steps (in units of mrt) are stored in
reverse order in *ALL-TIME-STEP-LIST*. These time steps may be used, or "shadowed",
by later simulations to direct the integration.

Time step shadowing is enabled when the global variable *USE-TIME-LIST* is set and
certain conditions are met.

By default, shadowed time steps are taken from the list *LAST-ALL-TIME-STEP-LIST*
when these values are consistent with the current simulation (primarily, the stop
times are the same).

If *USE-TIME-LIST* is set, but the time steps in *LAST-ALL-TIME-STEP-LIST* are not
appropriate, and the stop time of the last simulation and the current simulation is
the same, then *LAST-ALL-TIME-STEP-LIST* is set to the time steps from the last
simulation which are subsequently used for the current simulation.  Otherwise, time
step shadowing is cancelled.

If *AUTO-REFRESH-OF-LAST-ALL-TIME-LIST* is set then *LAST-ALL-TIME-STEP-LIST* is
set to the time steps from the last simulation.

While the conditions describe above is designed to check for inconsistencies, it is
not a bad idea to verify that the time steps used are the right ones.

Shadowing the time steps from a previous simulation is useful when doing precise
quantitative comparisons between simulations using variable time steps.  Although
traces from any two simulations may be compared by using the interpolating function
CONVERT-DATA-TIME-LISTS (see analysis.doc), there are some cases in which the
inevitable noise generated by this method can be irritating (for example when
analyzing small differences between two traces). See the voltage clamp protocol in
protocols.lisp for an example.


****************************************************************
****************************************************************

		      Ordering the Matrix

****************************************************************
****************************************************************


A fundamental contribution of Hines is recognizing that tree circuit
topologies (valid for any arbitrary network of neurons, without gap
junctions) can be ordered such that the resulting matrix is almost
tri-diagonal with far off-diagonals that may be eliminated in one
pass. The result is a matrix inversion that is O(n) (see the
description under HINES-SOLVE below).

The following description of branches is derived from Hines, 1984: A
branch is composed of connected segments. The ends of the branch are
determined by those segments which (at either end of the segment)
connect to more than one segment. The branches of a cell, and in turn
the branch segments, are numbered as follows: Choose any branch of the
tree which is connected at one end to the soma. Number the segments of
that branch so that the segment connected to the soma is the last
segment.  The first segment of this branch ('trunk') will be called
the 'branch node'. Note that this branch node is not the same thing as
a true circuit node (as referenced by Surf-Hippo).

The soma is also considered a 'branch node'.

All branches connecting to a branch node have their segments numbered
so that their last segment connects to this node. Their first segments
are also called branch nodes (as long as other segments are connected
to them), and this segment-numbering process continues until all the
segments are numbered. The last numbered branches, or 'twigs', all
have one end (their first segments) unconnected. Each branch node
becomes the center of a Wye network.

Continue this procedure for all other segments connected to the soma.

Branches are numbered as follows: Assume that there are N branches.
Starting at soma, number all the branches connecting to the soma
starting with N and decrementing. Continue numbering all the branches
that are connected to the previous set of branches, decrementing the
branch number.  Continue working out on the tree until all the
branches are labeled.

The two circuit nodes (proximal and distal) associated with each
segment are ordered according to the branch number and the number of
the attached segment in the proximal direction. Note that since the
circuit is a tree, there will only be one such segment for each node,
whereas there can be multiple segments attached to a node in the
distal direction. For example, if branch 33 has 2 segments and branch
34 has 3 segments, then the nodes would be ordered: ...33-1, 33-2,
34-1, 34-2, 34-3... The soma node has the highest node index.





****************************************************************
****************************************************************

		      Solving the Circuit

****************************************************************
****************************************************************

The implicit phase of the solution at each time step t -> t+dt
consists of solving the following matrix equation for V(t+dt/2): 


    (Almost) Tri-diagonal 
          matrix
   __________|__________
  /                     \

  [G(t+dt/2) - (2/dt * C)] * V(t+dt/2) = (2/dt * C * -V(t)) +
				         [G-elements(t+dt/2) * E_G-elements(t+dt/2)] +
	                    /		 I-Sources(t') 
                           /
              Solve for --'


Where, for the matrix on the left side of the equation,

    G_ik = sum of all conductances between nodes i and j (G-axials) <- i /= j
           sum of all conductances between node i and ground (G-elements) <- i = j
 
    C_ii = capacitance between node i and ground


G-elements refer to membrane conductances (leak, channels, synapses),
and E_G-elements refer to the appropriate reversal potentials. These
are the same conductances referred to above in the matrix on the left
which make up the sum G_ii. The product on the right hand side of the
equation above assumes that for each entry in the vector the product
represents the sum of products over all the node membrane elements.

Integration of the various gating particles which contribute product
terms to G-elements is done prior to the computation of the matrix
equation (see discussion of EVAL-ALL-ELEMENTS below).

Non-ideal voltage sources are handled as a very large membrane
conductance G-element (which corresponds to the series resistance of
the electrode) in series with a controlled E_G-element (battery) (see
also the Ideal Voltage Sources below and source.doc).

Since the axial resistances are constant, we can fix the off diagonal
terms before the simulation integration, where the G-axials are taken
between the nodes implied by the matrix indices corresponding to the
elements in the *upper-diag* and *lower-diag* arrays. These are
referred to above in the matrix on the left as the conductances which
make up the sum G_ik, (i not equal to k).

 *upper-diag* and *lower-diag* = (-) G-axials    (EVAL-SEGMENT)

V-AT-HALF-STEP node structure slots and matrix arrays refer to V(t+dt/2).

As pointed out by Hines, solving for V(t+dt/2) in the implicit step,
and then V(t+dt) explicitely is second order correct with respect to
both dt and compartment length, and is numerically stable (Cooley and
dodge, 1966; Joyner et al., 1978).

The variable *EVALUATE-INPUTS-AT-MIDPOINT* controls the relationship
between the input timing and the time step.  When true, at each time
step the circuit inputs (e.g. sources, driven synapses) are evaluated
at the midpoint of the step - otherwise, the inputs are evaluated for
the end of the step (the prediction time).





***************************************************************
***************************************************************

		 How The Code Does It, Briefly

***************************************************************
***************************************************************

(This description refers to an earlier release, but is still more or
less relevant)

The main loop is in DO-TIME-CONTROL. The following functions are
called directly from do-time-control at the start of the integration,
and/or from within HINES-STEP during the integration. This is a
condensed description; for the exact details please see the referenced
code.

At the beginning of each time step:

  (INITIALIZE-INTEGRATION)

	Evaluate variables DELTA-BACK, DELTA-FORWARD, HALF-DELTA-FOR-BACK, and
	SUM-DELTA-FOR-BACK which are used in the v-dep particle evaluations.

	 (setq delta-back (the single-float (* mrt (the single-float (* 0.5 last-time-step))))
	       delta-forward (the single-float (* mrt (the single-float (* 0.5 time-step)))))
	 (setq half-delta-for-back (the single-float (* 0.5 (the single-float (- delta-forward delta-back))))
	       sum-delta-for-back (the single-float (+ delta-forward delta-back)))


 (SET-SOURCES)

	Update the current sources. Voltage sources are handled by
	EVAL-ALL-ELEMENTS.

 (INIT-ALL-NODES)

	Clear tri-diag matrix, and initialize all the accumulator fields, including (NODE-JACOBIAN ND),
	(NODE-ALPHA-CHARGE ND) and (NODE-CURRENT ND), i.e.:

	  (setf (node-jacobian nd) (node-const-jacobian nd) 

 (UPDATE-NODES-V-INDEX)

       The :PRT-V-INDEX slot in each node is derived by an estimate of the
       voltage at time (t~) halfway between midpoints of last step and
       current step.  Depending on size of these two steps, V(t~) is either
       an interpolation between or an extrapolation beyond V(t-n-1) and
       V(t-n).  This estimate is then translated to an index for the alpha
       and beta rate constant arrays.

 (EVAL-ALL-ELEMENTS)

       Run all the eval routines for the circuit elements, each of which
       accumulates the jacobian, alpha-charge, current entries of the
       appropriate node, and accumulates the near off-diagonal entries of the
       tri-diag matrix, as appropriate. In some cases, the order in
       which different types of circuit elements is evaluated is important,
       for example, particles must be evaluated before channels. The
       order is as follows:

		 (EVAL-ALL-AXONS)
		 (EVAL-ALL-CONC-PRTS)
		 (EVAL-ALL-PRTS)
		 (EVAL-ALL-CHS)
		 (EVAL-ALL-SYNS)
		 ;; Otherwise, conc-ints are evaluated out of the inner loop, in DO-TIME-CONTROL.
		 (IF *EVAL-CONC-INTS-IN-INNER-LOOP*  (EVAL-ALL-CONC-INTS))
		 (EVAL-ALL-SOMAS)
		 (EVAL-ALL-SEGMENTS)
		 (EVAL-ALL-ISOURCES)
		 (EVAL-ALL-VSOURCES)


       For example (EVAL-SEGMENT SEG):

	First, a local variable ALPHA-CAP is set -

	 alpha-cap <- (* 2/dt (segment-capacitance seg))

	For a segment, the target node is the distal node (node-2). The
	:FLOATS slot of a node holds the variables that are continually
	updated during the integration (the :FLOATS slot of the various
	circuit element structures holds an array of the variables that are
	updated by the integration step - this is a kludge to avoiding CONSing):

	 node-2-floats <- (node-floats (segment-node-2 seg))

	Then, the node's ALPHA-CHARGE, CURRENT, and JACOBIAN slots are updated -

	   (setf (node-floats-aref-alpha-charge node-2-floats)    
	                (+ (node-floats-aref-alpha-charge node-2-floats)    
			   (* (node-floats-aref-voltage-n node-2-floats) alpha-cap)))

	   (setf (node-floats-aref-current node-2-floats)    
	                (- (node-floats-aref-current node-2-floats)    
			   (* (segment-g-leak seg) (segment-v-leak seg))))

	   (setf (node-floats-aref-jacobian node-2-floats)    
		        (+ (node-floats-aref-jacobian node-2-floats) alpha-cap))


	The particles are evaluated first: the particle states need to be
	integrated since the state kinetics are described by non-linear
	first-order differential equations. However, as pointed out by Hines,
	there is a non-zero delay between a change in a node voltage and the
	subsequent effect on a node channel conductance (since the time constants for the
	channel kinetics are always non-zero). Therefore, the particle state
	equations may be solved independently of the circuit matrix
	evaluation, with a completely (direct) explicit method. Particle
	states are evaluated at (t + dt/2).

	When all the elements are evaluated, that is their
	contributions to their associated circuit nodes have been
	accumulated, then for each the circuit node:

	      The node (ALPHA-CHARGE - CURRENT) -> RHS (Right Hand Side [of matrix equation])
	      The node JACOBIAN -> diag



 (EVAL-ALL-NODES)

	  Solve both implicit and explicit Hines step: Set the RHS,
	  solve the matrix (implicit step), update the voltage
	  estimate with the new V-at-half-steps (explicit step).

	  Implicit phase:

	      For every electrical node - 

    (SET-DIAG-RHS-FLOATS) [calls SET-RHS]

	      RHS = (2/dt * capacitance * V(t)) + (G-elements * E_G-elements)  

	      diag = Jacobian = (2/dt * capacitance) + G-axials + G-elements


    (HINES-SOLVE)

	  Upper triangularization of the matrix is accomplished by repeated
	  applications of the procedure TRIANG. Define a 'twig' as any branch
	  whose distal end is *not* connected to an un-TRIANGed branch
	  (including no branch at all). Now upper triangularize the matrix by
	  doing the following until there are only twigs left: Collect the set
	  of all current twigs, except any twigs which have already been
	  TRIANGed. Apply TRIANG to the remaining set of twigs, in the order
	  that they appear in the matrix. (See hines.lisp)

	(TRIANG)

	Then, for all the somas: 

		V_soma_i(t+dt/2) = RHS_i / diag_i,
		where i refers to the matrix index for soma_i.

	Now back substitute to complete the Gaussian elimination.

	(BKSUB)	


  Explicit phase:

    (EVAL-NODE-FLOATS)

	    Over all nodes:  V(t+dt) = ([2 * V(t+dt/2)] - V(t))




  Now, if using a variable time step, check the LTE and choose a new time step.

    (CALC-LTE-RATIO)

	Get LTE-RATIO =  *ABSOLUTE-VOLTAGE-ERROR* / estimated LTE

    (PICK-TIME-STEP)

	If the estimated LTE is 0, then CALC-LTE-RATIO returns 0
	(instead of infinity), and PICK-TIME-STEP interprets this
	"special" value of LTE-RATIO appropriately (constraining the
	new time step by MAX-STEP).

  If LTE-RATIO > 1.0 (or = 0), then advance integration, otherwise
  rerun last step with smaller time step.

  If last step was ok, then

    (SAVE-DATA)


****************************************************************
****************************************************************

	Ideal Voltage Sources

****************************************************************
****************************************************************

The implementation of ideal voltage sources takes advantage of the
fact that any connected subset of a tree topology is itself a tree,
which means that disconnected portions of a tree may be handled by the
Hines ordering applyed to each subtree. Thus, if a node is connected
to an ideal voltage source, the matrix is effectively reordered so
that node is no longer part of the matrix, splitting the node's cell
into two subtrees. As far as the matrix evaluation itself is concerned,
the subtrees are computed independently. 

The influence of the ideal voltage source must then propagate to a set
of N nodes connected to the node with the source. If the voltage
source is connected to (the distal node of) a segment, then N includes
the distal node of the voltage source segment's proximal segment, and
the proximal nodes of the distal segments of the voltage source
segment. If the voltage source is connected to a soma then N includes
the proximal nodes of the segments connected to the soma. For each of
the nodes in N, the ideal voltage source is treated as a membrane
conductance, where the conductance specific to that node is the
connecting segment axial conductance. For all nodes in N the "reversal
potential" is given by the voltage source voltage. Thus, when the
voltage source is evaluated at a given time step, the node jacobians
and currents of the N nodes are updated in the same manner as node
jacobians and currents associated with channels or synapses.  After
all elements are evaluated, these jacobians and currents are
transferred to the matrix diagonal and right hand side arrays,
respectively, and the matrix is solved.

The voltage of the ideal voltage source node is updated directly with
the value of the voltage source voltage, and all membrane elements
associated with that node are evaluated as usual. Note, however, that
since the source is ideal, membrane elements on the same node have no
effect (with respect to current) on the behavior of the rest of the
circuit.



Relevant functions:


	For stripping out ideal voltage source nodes from the branches
	which form the circuit matrix -

		BUILD-BRANCH-LIST

	For evalation of the ideal voltage sources -

		CHECK-FIXED-VOLTAGE-NODES
		GET-VSOURCE-CURRENT
		EVAL-FIXED-NODE-VOLTAGES

	For setting up the matrix -

		REORDER-CIRCUIT
		ADD-SEGS-TO-OFF-DIAGS-DOUBLE
		INITIALIZE-SEG-NODE-JACOBIANS-AND-CURRENTS
		INITIALIZE-SOMA-NODE-JACOBIANS-AND-CURRENTS


	For choosing the circuit elements that need to be evaluated -

		MAKE-SEGMENT-ARRAY
		MAKE-SOMA-ARRAY

	For solving the matrix -

		TRIANG-DOUBLE
		BKSUB-DOUBLE
		HINES-SOLVE










