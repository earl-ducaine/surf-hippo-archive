;;; -*- Mode: LISP -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                microCAD2NC                 ;;;
;;;               FORWARD  part                ;;;
;;;         Feature Aggregation Rules          ;;;
;;;    (c) Knut Hinkelmann                     ;;;
;;;        Martin Harm       September 1991    ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Features derived by these rules are asserted into the ABox
; of TAXON. Attributes common to all features are the
; leftmost and rightmost surface the feature is covering.
; This is necessary to chaeck neighbarhood of surfaces and features.


; A shoulder is a feature consisting of two components:
; The ground is a longturning surface.
; The flank is either a descending surface (on the left)
; or an ascending surface (on the right) of the longturning
; surface. An additional condition is that the radius of the
; longturning surface is not greater than that of the
; descending or ascending surface, respectively.
;
; Examples:
;                         |         \
;                         |   or     \
;       __________________|           \________________
;

(up (add-data shoulder _featid
			(tup (tup ground _ltsid)
			     (tup flank _id2)
			     (tup leftmost _l)
			     (tup rightmost _id2)))
    (asc-tc _id2  `(tup (tup center1 _zl)
			(tup center2 _zr)
			(tup radius1 _rad)
			(tup radius2 _rado)))
    (neighbor _r _id2 )
    (data longturningsurface _ltsid
			     `(tup  (tup radius _rad-lts)
			 	    (tup leftmost _l)
				    (tup rightmost _r)))
    (>= _rad-lts _rad)
    (< _rad-lts _rado)
    (is _featid (make-instance-name shoulder _ltsid _id2)))
    


(up (add-data shoulder _featid 
			(tup (tup ground _ltsid)
			     (tup flank _id2)
			     (tup leftmost _id2)
			     (tup rightmost _r)))
    (desc-tc _id2 `(tup (tup center1 _zl)
		        (tup center2 _zl)
		        (tup radius1 _rado)
		        (tup radius2 _rad)))
    (neighbor _id2 _l)
    (data longturningsurface  _ltsid
			      `(tup (tup radius _rad-lts)
				    (tup leftmost _l)
				    (tup rightmost _r)))
    (>= _rad-lts _rad)
    (< _rad-lts _rado)
    (is _featid (make-instance-name shoulder _id2 _ltsid) ))


; A groove is an aggregation of two shoulder:
; a left shoulder and a right shoulder with common ground:
;
;          |                          /
;          |                         /
;          |________________________/
;
(up (add-data groove _featid 
		      (tup (tup leftflank _id1)
			   (tup ground _id2)
			   (tup rightflank _id3)
			   (tup leftmost _lsleft)
			   (tup rightmost _rsright)))
    (data rshoulder _rshid
		    `(tup (tup ground _id2)
		          (tup flank _id3)
			  (tup leftmost _rsleft)
			  (tup rightmost _rsright)))
    (data lshoulder _lshid
		    `(tup (tup ground _id2)
			  (tup flank _id1)
			  (tup leftmost _lsleft)
			  (tup rightmost _lsright)))
    (is _featid (make-instance-name groove _id1 _id2 _id3)))


; There are three definitions for a longturning surface:
; 1. Each cylinder is a longturning surface
; 2. Starting from a descending surface a longturning surface
;    Extends to the right until either the workpiece ends or
;    the radius of a surface exceeds the radius of the descinding
;    surface. The radius of such a longturning surface is the
;    radius of the highest surface covered by the longturning surface.
;
;     \
;      \......____.........        (the dashed line shows the
;       \    /   |____/\___         longturning surface)
;        \__/             |
;
; 3. Similar as 2. starting at an ascending surface and going
;    to the left.


(up (add-data longturningsurface _cyl
                                 (tup (tup radius _rad)
                                      (tup leftmost _cyl)
                                      (tup rightmost _cyl)))
    (truncone _cyl (tup (tup center1 _zl)
                        (tup center2 _zr)
			(tup radius1 _rad)
			(tup radius2 _rad))))

(up (add-data longturningsurface _featid
			         (tup (tup radius _rad)
				      (tup leftmost _l)
				      (tup rightmost _rightm)))

    (asc-tc _right-end
	     `(tup (tup center1 _zl)
                   (tup center2 _zr)
		   (tup radius1 _rad-first)
		   (tup radius2 _rad-limit)))
    (neighbor _rightm _right-end)
    (is _rad (once
	       `(sub-lts-from-left (tup rad-max _rad-first)
				  (tup rad-limit _rad-limit)
				  (tup leftmost _l)
                                  (tup rightmost _rightm))))
    (different-tc _l _rightm)
    (is _featid (make-instance-name lts _l _rightm)))

(ft (sub-lts-from-left
     (tup rad-max _rad-max)       ;;; bisheriges maximum
     (tup rad-limit _rad-limit)   ;;; obere schranke( darf nicht! erreicht werden)
     (tup leftmost _l)
     (tup rightmost _tc))
    (neighbor _next-tc _tc)
    (truncone _next-tc
	      `(tup (tup center1 _zl)
		    (tup center2 _zr)
		    (tup radius1 _rada)
		    (tup radius2 _radb)))
    (< _rada _rad-limit)
    (is _new-max (max _rad-max _rada))
    (sub-lts-from-left 
        `(tup rad-max _new-max)      ; bisheriges maximum
	`(tup rad-limit _rad-limit)  ; obere schranke( darf nicht! erreicht werden)
	`(tup leftmost _l)
        `(tup rightmost _next-tc)))


(ft (sub-lts-from-left (tup rad-max _the-max)
                       (tup rad-limit _rad-limit)
                       (tup leftmost _tc)
                       (tup rightmost _tc))
    _the-max)


; up add-data
(up (add-data longturningsurface _featid
	                         (tup (tup radius _rad)
		                      (tup leftmost _leftm)
		                      (tup rightmost _r)))

    (desc-tc _left-end
	     `(tup (tup center1 _zl)
                   (tup center2 _zr)
		   (tup radius1 _rad-limit)
		   (tup radius2 _rad-first)))
    (neighbor _left-end _leftm)
    (is _rad (once
	      `(sub-lts-from-right (tup rad-max _rad-first)
				  (tup rad-limit _rad-limit)
				  (tup rightmost _r)
                                  (tup leftmost _leftm))))
    (different-tc _r _leftm)
    (is _featid (make-instance-name lts _leftm _r)))

(ft (sub-lts-from-right
     (tup rad-max _rad-max)       ;;; bisheriges maximum
     (tup rad-limit _rad-limit)   ;;; obere schranke( darf nicht! erreicht werden)
     (tup rightmost _r)
     (tup leftmost _tc))
    (neighbor _tc _next-tc)
    (truncone _next-tc
	      `(tup (tup center1 _zl)
		    (tup center2 _zr)
		    (tup radius1 _rada)
		    (tup radius2 _radb)))
    (< _radb _rad-limit)
    (is _new-max (max _rad-max _radb))
    (sub-lts-from-right `(tup rad-max _new-max)   
                        `(tup rad-limit _rad-limit)
                        `(tup rightmost _r)
                        `(tup leftmost _next-tc)))


(ft (sub-lts-from-right (tup rad-max _the-max)
                        (tup rad-limit _rad-limit)
                        (tup rightmost _tc)
                        (tup leftmost _tc))
    _the-max)



(hn (peak (feat _id1 _id2)
	  (tup leftmost _id1)
	  (tup rightmost _id2))
    (asc-tc _id1 `(tup (tup center1 _zl)
		       (tup center2 _zr1)
		       (tup radius1 _rada)
		       (tup radius2 _radb)))
    (neighbor _id1 _id2)
    (desc-tc _id2 `(tup (tup center1 _zr1) 
			(tup center2 _zr2)
			(tup radius1 _radb)
			(tup radius2 _radb2)))
    )


(hn (nutch (feat _id1 _id2)
	   (tup leftmost _id1)
	   (tup rightmost _id2))
    (desc-tc _id1 `(tup (tup center1 _zl)
			(tup center2 _zr1)
			(tup radius1 _rada)
			(tup radius2 _radb)))
    (neighbor _id1 _id2)
    (asc-tc _id2 `(tup (tup center1 _zr1)
		       (tup center2 _zr2)
		       (tup radius1 _radb)
		       (tup radius2 _radb2))))

(hn (different-tc _tc1 _tc2)
    (nou _tc1 _tc2))


; Ascending truncated cone: First radius is greater than second radius
(rl (asc-tc _x (tup (tup center1 _zl)
                    (tup center2 _zr)
                    (tup radius1 _rada)
		    (tup radius2 _radb)))
    (truncone _x `(tup (tup center1 _zl)
		       (tup center2 _zr)
		       (tup radius1 _rada)
		       (tup radius2 _radb)))
    (< _rada _radb))


; Descending truncated cone: First radius is smaller than second radius
(rl (desc-tc _x (tup (tup center1 _zl)
		     (tup center2 _zr)
		     (tup radius1 _rada)
		     (tup radius2 _radb)))
    (truncone _x `(tup (tup center1 _zl)
		       (tup center2 _zr)
		       (tup radius1 _rada)
		       (tup radius2 _radb)))
    (> _rada _radb))



; Truncated cone is the general form of a rotation symmetric surface.
; Therefore every surface is a truncated cone.
(rl (truncone _x (tup (tup center1 _zl)
                      (tup center2 _zr)
		      (tup radius1 _rada)
		      (tup radius2 _rada)))
    (cylinder _x `(tup (tup center1 _zl)
		       (tup center2 _zr)
		       (tup radius1 _rada)
		       (tup  radius2 _rada))))

(rl (truncone _x (tup (tup center1 _zl)
		      (tup center2 _zl)
		      (tup radius1 _rada)
		      (tup radius2 _radb)))
    (ring _x `(tup (tup center1 _zl)
		   (tup center2 _zl)
		   (tup radius1 _rada)
		   (tup radius2 _radb))))

(rl (truncone _x (tup (tup center1 _zl)
		      (tup center2 _zl)
		      (tup radius1 _rada)
		      (tup radius2 0)))
    (circle _x `(tup (tup center1 _zl)
		     (tup center2 _zl)
		     (tup radius1 _rada)
		     (tup radius2 0))))

(rl (truncone _x (tup (tup center1 _zl)
		      (tup center2 _zl)
		      (tup radius1 0)
		      (tup radius2 _radb)))
    (circle _x `(tup (tup center1 _zl)
		     (tup center2 _zl)
		     (tup radius1 0)
		     (tup radius2 _radb))))

(rl (truncone _x (tup (tup center1 _zl)
		      (tup center2 _zr)
		      (tup radius1 _rada)
		      (tup radius2 0)))
    (cone _x `(tup (tup center1 _zl)
		   (tup center2 _zr)
		   (tup radius1 _rada)
		   (tup radius2 0))))

(rl (truncone _x (tup (tup center1 _zl)
		      (tup center2 _zr)
		      (tup radius1 0)
		      (tup radius2 _radb)))
    (cone _x `(tup (tup center1 _zl)
		   (tup center2 _zr)
		   (tup radius1 0)
		   (tup radius2 _radb))))
