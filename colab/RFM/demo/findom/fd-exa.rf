; Beispiele fuer Finite-Domain-Constraints in RELFUN    (c) M. Sintek 6/92
; ========================================================================

; Es lassen sich jetzt auch einfache FD-Constraints in RELFUN
; ausdruecken.

; RELFUN musste dafuer nicht erweitert werden --
; es wurden nur die Praedikate var/1 und nonvar/1 eingefuehrt, und zwar
; auf folgende einfache Weise:

#| (Dies ist ein Ausschnitt aus "gwaminit.asm")

      .proc ; collection of meta-logical test predicates
var/1 (set_index_number 1)
      (switch_on_term "fail" "fail" "fail" "fail" "proceed")

nonvar/1
      (set_index_number 1)
      (switch_on_term "proceed" "proceed" "proceed" "proceed" "fail")

"proceed"
      (proceed)

"fail"
      (fail)

|#



; Die Deklaration von Constraint-Variablen geschieht mit
;   (<var> : `(fd <dom> <expr>)) ,
; wobei <dom> eine normale RELFUN-Liste (tup) und <expr> irgendein
; beliebiger Ausdruck ist (dieser wird hauptsaechlich fuer die
; Ausgabe einer Constraint-Variablen benutzt).

; Desweiteren gibt es zwei grundlegende Constraints: fd= und fd/=
; (also Gleichheit und Ungleichheit).


; Beispiel:


(hn (test)

  (_x : `(fd (tup 1 2 3) x))
  (_y : `(fd (tup 2 3 4) y))
  (_z : `(fd (tup 1 3 5) z))

  (fd-print _x) (fd-print _y) (fd-print _z) (rf-terpri)

  (fd= _x _y)

  (fd-print _x) (fd-print _y) (fd-print _z) (rf-terpri)

  (fd/= _x _z)

  (rf-princ general\ solution\:) (rf-terpri)
  (fd-print _x) (fd-print _y) (fd-print _z) (rf-terpri)

  (rf-princ single\ solutions\:) (rf-terpri)
  (fd-single-solutions `(tup _x _y _z)) ; Einschraenkung auf jeweils ein Element
  (fd-sprint _x)
  (fd-sprint _y)
  (fd-sprint _z))



#|

rfe-l> (test)
x = (tup 1 2 3)
y = (tup 2 3 4)
z = (tup 1 3 5)

x = (tup 2 3)
y = (tup 2 3)
z = (tup 1 3 5)

general solution:
x = (tup 3 2)
y = (tup 3 2)
z = (tup 1 5)

single solutions:
x = 3 ; es wird gmaess globaler Konsistenz korrekt ausmultipliziert
y = 3 ; (es wird also nie x = 3 mit y = 2 kombiniert)
z = 1
true

More solutions?  (Y/N) y


x = 3
y = 3
z = 5
true

More solutions?  (Y/N) y


x = 2
y = 2
z = 1
true

More solutions?  (Y/N) y


x = 2
y = 2
z = 5
true

More solutions?  (Y/N) y


general solution:
x = (tup 2)
y = (tup 2)
z = (tup 3 1 5)

single solutions:
x = 2
y = 2
z = 3
true

....


|#


; Graphenfaerbung
; ----------------

; k1  ----  k4  ; alle verbundenen Knoten muessen verschiedene Farben haben
; |        /|
; |  ------ |
; | /       |
; k2  ----  k5
; |         |
; k3  ----  k6


(hn (gc)

  (is _colours `(tup red green blue yellow)) ; Domaindeklaration

  (_k1 : `(fd _colours k1)) ; Constraintvariablen-Dekl.
  (_k2 : `(fd _colours k2)) ; die Konstanten k1 .. k6 sind nur fuer
  (_k3 : `(fd _colours k3)) ; die Ausgabe mit fd-print
  (_k4 : `(fd _colours k4)) ; (in PROLOG: (fd-var _k1 _colours k1) )
  (_k5 : `(fd _colours k5))
  (_k6 : `(fd _colours k6))

  (gc-print _k1 _k2 _k3 _k4 _k5 _k6)

  (rf-print cut) (rf-terpri)
  ; alles ueber "cut" stehende wird nur einmal ! ausgefuehrt
  ; (siehe Script unten: "cut" wird nur einmal ausgegeben);
  ; insbesondere sind die Deklarationen der Domainvariablen keine
  ; Generatoren (wie man dies ueblicherweise in PROLOG implementieren
  ; wuerde)

  (fd/= _k1 _k2) ; Ungleichheitsconstraint fd/=
  (fd/= _k2 _k3) ; es werden wirklich backtracking-faehig die Constraint-
  (fd/= _k2 _k4) ; Variablen "mengenmaessig" eingeschraengt
  (fd/= _k4 _k5)
  (fd/= _k5 _k6)
  (fd/= _k1 _k4)
  (fd/= _k2 _k5)
  (fd/= _k3 _k6)

  (gc-print _k1 _k2 _k3 _k4 _k5 _k6))


(hn (gc-print _k1 _k2 _k3 _k4 _k5 _k6)
  (fd-print _k1)
  (fd-print _k2)
  (fd-print _k3)
  (fd-print _k4)
  (fd-print _k5)
  (fd-print _k6)
  (rf-terpri))


#|
rfe-l> (gc)
k1 = (tup red green blue yellow)
k2 = (tup red green blue yellow)
k3 = (tup red green blue yellow)
k4 = (tup red green blue yellow)
k5 = (tup red green blue yellow)
k6 = (tup red green blue yellow)

cut ; <<< wird nur einmal ausgegeben !
k1 = (tup red)
k2 = (tup green)
k3 = (tup red)
k4 = (tup blue)
k5 = (tup yellow red) ; Ausmultiplizieren (mit fd-single-solutions)
k6 = (tup blue)       ; erzeugt alle Loesungen

true

More solutions?  (Y/N) y


k1 = (tup red) ; (es werden leider auch doppelte Loesungen erzeugt)
k2 = (tup green)
k3 = (tup red)
k4 = (tup blue)
k5 = (tup yellow red)
k6 = (tup blue)

true

More solutions?  (Y/N) y


k1 = (tup red)
k2 = (tup green)
k3 = (tup red)
k4 = (tup blue)
k5 = (tup yellow)
k6 = (tup green blue)

true

More solutions?  (Y/N) n ; ...

rfe-l>

|#


; Das 8 Damen Problem
; -------------------

(hn (queens _y1 (queen _x1) _y2 (queen _x2)) ; _x1 /= _x2
  ; queens stellt sicher, dass sich zwei Damen (_x1/_y1) und (_x2/_y2)
  ; nicht schlagen koennen
  (/= _y1 _y2) ; not on same row
  (is _diff (- _x2 _x1))
  (/= (+ _y1 _diff) _y2)  ; diagonals
  (/= (- _y1 _diff) _y2))


(hn (8q)

  (rf-princ 8\ Queens\ Problem\:)
  (rf-terpri)

  (is _rows `(tup 1 2 3 4 5 6 7 8))

  (_q1 : `(fd _rows (queen 1)))
  (_q2 : `(fd _rows (queen 2)))
  (_q3 : `(fd _rows (queen 3)))
  (_q4 : `(fd _rows (queen 4)))
  (_q5 : `(fd _rows (queen 5)))
  (_q6 : `(fd _rows (queen 6)))
  (_q7 : `(fd _rows (queen 7)))
  (_q8 : `(fd _rows (queen 8)))

  (`(fd-constr queens) _q2 _q1) ; fd-constr ist eine HO-Funktion, die
                                ; aus einem Constraint, das auf Elementen
  (`(fd-constr queens) _q3 _q2) ; arbeitet (hier queens) eine Constraint-
  (`(fd-constr queens) _q3 _q1) ; Funktion macht, die auf echten Mengen
				; (Constraintvariablen) arbeitet
  (`(fd-constr queens) _q4 _q3)
  (`(fd-constr queens) _q4 _q2)
  (`(fd-constr queens) _q4 _q1)

  (`(fd-constr queens) _q5 _q4)
  (`(fd-constr queens) _q5 _q3)
  (`(fd-constr queens) _q5 _q2)
  (`(fd-constr queens) _q5 _q1)

  (`(fd-constr queens) _q6 _q5)
  (`(fd-constr queens) _q6 _q4)
  (`(fd-constr queens) _q6 _q3)
  (`(fd-constr queens) _q6 _q2)
  (`(fd-constr queens) _q6 _q1)

  (`(fd-constr queens) _q7 _q6)
  (`(fd-constr queens) _q7 _q5)
  (`(fd-constr queens) _q7 _q4)
  (`(fd-constr queens) _q7 _q3)
  (`(fd-constr queens) _q7 _q2)
  (`(fd-constr queens) _q7 _q1)

  (`(fd-constr queens) _q8 _q7)
  (`(fd-constr queens) _q8 _q6)
  (`(fd-constr queens) _q8 _q5)
  (`(fd-constr queens) _q8 _q4)
  (`(fd-constr queens) _q8 _q3)
  (`(fd-constr queens) _q8 _q2)
  (`(fd-constr queens) _q8 _q1)


  (fd-print _q1)
  (fd-print _q2)
  (fd-print _q3)
  (fd-print _q4)
  (fd-print _q5)
  (fd-print _q6)
  (fd-print _q7)
  (fd-print _q8)

  )




#|
rfe-l> (8q)
8 queens problem:
(queen 1) = (tup 7) ; 1. Dame hat Koordinate (1/7) ...
(queen 2) = (tup 1)
(queen 3) = (tup 3)
(queen 4) = (tup 8)
(queen 5) = (tup 6)
(queen 6) = (tup 4)
(queen 7) = (tup 2)
(queen 8) = (tup 5)
true

More solutions?  (Y/N) n ; ...

rfe-l>
|#


; Das N Damen Problem
; -------------------


(hn (nq _n)

  (is _rows (do-n-to-m 1 _n (lambda (_i) _i))) ; (tup 1 ... _n)

  (is _queens (do-n-to-m 1 _n ; erzeugt Liste der Constraintvariablen
		(lambda (_i &aux _queen)
			(_queen : `(fd _rows (queen _i))))))

  (commutative-complete-constraint queens _queens _n) ; queens wie oben def.

  (print-fd-vars _queens))



(hn (commutative-complete-constraint _pred _vars _n)
  (do-n-to-m 2 _n
    (lambda (_i)
      (do-n-to-m 1 (1- _i)
	(lambda (_j)
	  (`(fd-constr _pred) (rf-nth _vars _i) (rf-nth _vars _j)))))))


; axiliaries:

(hn (print-fd-vars (tup)))
(hn (print-fd-vars (tup _v | _rest))
  (fd-print _v)
  (print-fd-vars _rest))


; (do-n-to-m _n _m _fct):
; for _i = _n to _m do (_fct _i), return tup of results

(ft (do-n-to-m _n _m _fct)
  (> _n _m)
  `(tup))
(ft (do-n-to-m _n _m _fct)
  (<= _n _m)
  (tup (_fct _n) | (do-n-to-m (1+ _n) _m _fct)))


(ft (rf-nth (tup _x | id) 1) _x)
(ft (rf-nth (tup _x | _rest) _n)
  (> _n 1)
  (rf-nth _rest (1- _n)))



#|
rfe-l> (nq 6)
(queen 1) = (tup 4)
(queen 2) = (tup 1)
(queen 3) = (tup 5)
(queen 4) = (tup 2)
(queen 5) = (tup 6)
(queen 6) = (tup 3)
true

More solutions?  (Y/N)



rfe-l> (nq 9)
(queen 1) = (tup 3)
(queen 2) = (tup 1)
(queen 3) = (tup 4)
(queen 4) = (tup 7)
(queen 5) = (tup 9)
(queen 6) = (tup 2)
(queen 7) = (tup 5)
(queen 8) = (tup 8)
(queen 9) = (tup 6)
true

More solutions?  (Y/N)
|#
