; Datei /home/forward/release/FORWARD/taxon-interface/tx-access.rf
; Datum: 10.9.1991
; 
; Spezifikation des Zugriffs von FORWARD/RELFUN auf TAXON
;
; realisiert im Rahmen von microCAD2NC
;
;
;
; In FORWARD muss man unterscheiden koennen zwischen Fakten, die
; im eigenen Working Memory stehen und solchen, die in der ABox von TAXON
; zu testen sind: Dazu wird ein Operator ADD-DATA in der Konklusion
; eingefuehrt. Das Argument von ADD-DATA ist ein Konzept-Term der Form
; 
;     (ADD-DATA (<concept-name>
;                <instance-name>
;                (tup (<attr1> <val1>)
;                     ...
;                     (<attrN> <valN>))))
; 
; Fuer Praemissen, die auf solche Instanzen zugreifen, wird ein
; neuer built-in Operator DATA benoetigt
; 
; (up (add-data (groove (feat _x _y _z) ...)
;     (data (rshoulder (feat _x _y) ...))
;     (data (lshoulder (feat _y _z) ...)))
; 
; Der Operator DATA ist so definiert, dass er gerade den Zugriff auf die
; ABox realisiert:
 
(hn (data (_concept _instance  _attr-terms))
    (member _instance (tx instances _concept))
    (is _attr-terms (data-attributes _instance _attr-terms)))
;(hn (data (_concept _instance  _attr-terms))
;;    (naf (member _instance (tx instances _concept)))
;    (add-data `(_concept _instance  _attr-terms))
;    (retain `(_concept _instance  _attr-terms)))



; Die Funktion data-attributes holt nacheinander die Attribute der
; angegebenen Instanz aus der ABox

(ft (data-attributes _instance))
(ft (data-attributes _instance (tup (_attr _val)))
    (is _val (tx attr-filler _attr _instance))
    `(tup (_attr _val)))
(ft (data-attributes _instance (tup (_attr _val) (_attr2 _val2) | _attr-terms))
    (is _val (tx attr-filler _attr _instance))
    (is _rest-terms (data-attributes _instance
                                     `(tup (_attr2 _val2) | _attr-terms)))
    `(tup (_attr _val) | _rest-terms))


; Auch beim Speichern in den retain-Stack sind Aenderungen notwendig. So
; wird nur die Instanz mit ihren Attributen im retain-Stack abgelegt, da
; die konkrete Zuordnung erst kurz vor dem Expandieren ermittelt wird.
; 
; Das Argument von retain kann die Konklusion einer Regel sein, die als
; Instanz in die TAXON ABox eingetragen werden soll. Sie hat die Form: 
;     (ADD-DATA (<concept-name>
;                <instance-name>
;                (tup (<attr1> <val1>)
;                     ...
;                     (<attrN> <valN>))))

(hn (retain (add-data (_concept _instance-name _args)))
    (not-reached `(data (_concept _instance-name _args)))
    (is t (tx assert-ind? _instance-name _concept _args))
    (rf-pprint "Asserted into TAXON ABox:")
    (rf-pprint `(_concept _instance-name _args))
    (rf-terpri)
    (push-fact-retain `(data (_concept _instance-name _args))))
(hn (retain _Fact) (nou _Fact `(add-data _x))
                   (not-reached _Fact)
                   (push-fact-retain _Fact))


; Wenn man einen Fakt aus dem Retain-Stack nimmt, der eine ABox-Instanz
; ist, wird diese realisiert, jedem der (allgemeineren) Konzepte
; zugeordnet, und damit Regeln getriggert. Wenn es sich nicht um einen
; ABox-Fakt handelt, laeuft das Triggern der Regeln wie vorher.

(hn (my-unify _x _x))

(hn (open-node _Fact) (is _x (get-open-node))
; (is (data (_old-concept _name  _attr-terms)) (get-open-node))
                      (my-unify `(data (_old-concept _name  _attr-terms)) _x)
                      (next-open-node)
		      (is _cc (tx concept-closure _name))
                      (rf-print "TAXON realization for")
                      (rf-princ _name)
                      (rf-princ ": ")
                      (rf-pprint _cc)
		      (member _concept _cc)
		      (is _Fact
		          `(data (_concept _name  _attr-terms)))
                      (rf-pprint "Trying forward rules with fact:")
                      (rf-pprint _Fact)
                      (rf-terpri))
(hn (open-node _Fact) (is _Fact (get-open-node))
		      (nou _Fact `(data _x))
                      (next-open-node))
(hn (open-node _Fact) (not-open-node-at-end) (open-node _Fact))



(hn (member _e (tup _e | _l)))
(hn (member _e (tup _a | _l)) (member _e _l))

(hn (nou _x _x) ! unknown)
(hn (nou _x _y))


; diverse Ableitungsstrategien
(hn (forward-loaded))

; Depth first:

; (df-enum `(tup _Fact | _Rest) _Inference) berechnet alle Konsequenzen
; fuer eine Liste von Fakten (Tiefensuche).
; (df-enum _Fact _Inference) zaehlt die Konsequenzen EINES Faktes auf.
; Da das erste Argument immer gebunden ist und da Fakten nie tup
; als Funktor haben, kann fuer eine Anfrage nur entweder die erste
; oder die zweite und drite Klausel anwendbar sein, aber nie alle.
(ft (df-enum (tup _Fact | _Rest) _Inference)
    (fc-initialize)
    (satisfied `(tup _Fact | _Rest))
    (df-elist `(tup _Fact | _Rest) _Inference))
(ft (df-enum _Fact _Inference)
    (nou _Fact `(tup | _x))
    (fc-initialize)
    ;@_Fact
    (df-one _Fact _Inference))
(ft (df-enum _x _y) 
    (reset-retain) 
    unknown)

(ft (df-elist (tup _Fact | _Rest) _Inference)
    (df-one _Fact _Inference))
(ft (df-elist (tup _First | _Rest) _Inference)
    (df-elist _Rest _Inference))

(ft (df-one (add-data (_old-concept _instance _attr-terms)) _Inference)
    (member _concept (tx concept-closure _instance))
    (forward `(data (_concept _instance  _attr-terms)) _Conclusion)
    (df-one-more _Conclusion _Inference))
(ft (df-one _Fact _Inference)
    (nou _Fact `(add-data _x))
    (forward _Fact _Conclusion)
    (df-one-more _Conclusion _Inference))
(ft (df-one-more _Conclusion _Conclusion) _Conclusion)
(ft (df-one-more _Conclusion _Next)
    (df-one _Conclusion _Next))

;
;
;
;
(ft (df-all (tup _Fact | _Rest) _Inference)
    (fc-initialize)
    (satisfied `(tup _Fact | _Rest))
    (df-alist `(tup _Fact | _Rest) _Inference))
(ft (df-all _Fact _Inference)
    (nou _Fact `(tup | _x))
    (fc-initialize)
    ;;;@_Fact
    (df-all1 _Fact _Inference))
(ft (df-all _x _Inference-pattern)
    (is _Inferences (collect-facts))
    (is _Inference-list (filter _Inference-pattern _Inferences))
    (reset-retain)
    _Inference-list)

(ft (df-alist (tup _Fact | _Rest) _Inference)
    (df-all1 _Fact _Inference))
(ft (df-alist (tup _First | _Rest) _Inference)
    (df-alist _Rest _Inference))

(ft (df-all1 (add-data (_old-concept _instance _attr-terms)) _Inference)
    (member _concept (tx concept-closure _instance))
    (forward `(data (_concept instance  _attr-terms)) _Conclusion)
    (df-all1 _Conclusion _Inference))
(ft (df-all1 _Fact _Inference)
    (nou _Fact `(add-data _x))
    (forward _Fact _Conclusion)
    (df-all1 _Conclusion _Inference))

; Einzelaufzaehlung der Konsequenzen einer Liste von Fakten mit
; Breitensuche: (bf-enum `(tup _Fact | _Rest) _Inference)
; (bf-enum _Fact _Inference) zaehlt die Konsequenzen EINES Faktes auf.
; Da das erste Argument immer gebunden ist und da Fakten nie tup
; als Funktor haben, kann fuer eine Anfrage nur entweder die erste
; oder die zweite und drite Klausel anwendbar sein, aber nie alle.
(ft (bf-enum (tup _Fact | _Rest) _Inference)
    (fc-initialize)
    (satisfied `(tup _Fact | _Rest))
    (bf-elist `(tup _Fact | _Rest) _Inference))
(ft (bf-enum _Fact _Inference)
    (nou _Fact `(tup | _x))
    (fc-initialize)
    ;@_Fact
    (forward _Fact _Inference)
    _Inference)
(ft (bf-enum _Fact _Inference) 
    ;@_Fact 
    (forward-one _Inference))
(ft (bf-enum _x _y) (reset-retain) unknown)

(ft (bf-elist (tup _Fact | _Rest) _Inference)
    (forward _Fact _Inference)
    _Inference)
(ft (bf-elist (tup _First | _Rest) _Inference)
    (bf-elist _Rest _Inference))
(ft (bf-elist (tup) _Inference)
    (forward-one _Inference))

(ft (forward-one _Inference)
    (open-node _Fact)
    (forward _Fact _Inference)
    _Inference)


; (bf-all `(tup _Fact | _Rest) _Inference-pattern)  hat als WERT die
; Liste aller Konsequenzen der Liste von Fakten (tup _Fact | _Rest),
; die mit dem Pattern _Inference-pattern unifizierbar sind:
; (bf-all _Fact _Inference-pattern) leitet alle
; Konsequenzen des initialen Fakts _Fact ab.
; Der WERT ist die Liste aller Konsequenzen, die mit dem
; Pattern _Inference-pattern unifizierbar sind.
(ft (bf-all (tup _Fact | _Rest) _Inference-pattern)
    (fc-initialize)
    (satisfied `(tup _Fact | _Rest))
    (bf-alist `(tup _Fact | _Rest) _Inference-pattern))
(hn (bf-all _Fact _Inference-pattern)
    (nou _Fact `(tup | _x))
    (fc-initialize)
    ;@_Fact
    (forward _Fact _Conclusion)
    false)
(ft (bf-all _Fact _Inference-pattern)
    (forward-all)
    (is _Inferences (collect-facts))
    (is _Inference-list (filter _Inference-pattern _Inferences))
    (reset-retain)
    _Inference-list)

(hn (bf-alist (tup _Fact | _Rest) _Inference-pattern)
    (forward _Fact _Inference)
    false)
(ft (bf-alist (tup _Fact | _Rest) _Inference-pattern)
    (bf-alist _Rest _Inference-pattern))

(hn (forward-all)
    (open-node _Fact)
    (forward _Fact _Conclusion)
    false)
(hn (forward-all))





; The initial facts of for forward reasoning must be satisfied, so that
; the can be used for proving premises of rules.
; Instead of simply testing it would be possible to assert them if
; they are not already satisfied.
(hn (satisfied (tup)))
(hn (satisfied (tup _Fact | _Rest))
    ;@_Fact
    (satisfied _Rest))

; All at once
;(hn (open-node _Fact) 
;    (is _Fact (get-open-node))
;    (next-open-node))
;(hn (open-node _Fact) 
;    (not-open-node-at-end) 
;    (open-node _Fact))



;(hn (retain _Fact)
;    (not-reached _Fact) 
;    (push-fact-retain _Fact))


(hn (not-reached _Conclusion)
    (is t (subsumes-value _Conclusion)))

(hn (reset-retain))

;(ft (tup | _rest) `(tup | _rest))

