;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   finite domains in RELFUN   ;;;
;;; (c) Michael Sintek   June 92 ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



; reassignment variables (rav)
; ----------------------------

(ft (rav-get _var _x)
  (var _var)
  (is _x _var)
  unbound)

(ft (rav-get _rav _x)
  (nonvar _rav)
  (is _rav `(tup _val | _var))
  (var _var)
  (is _x _var)
  _val)

(ft (rav-get _rav _x)
  (nonvar _rav)
  (is _rav `(tup id | _rest))
  (nonvar _rest)
  (rav-get _rest _x))


(ft (rav-set _rav _x)            ; returns previous value of _rav and sets
  (rav-get _rav `(tup _x | id))) ; _rav to _x

(ft (rav-set* `(tup _x | id) _x)) ; "fast" set

(ft (rav-set** `(tup _x | _next) _x _next)) ; "fast" set for sync


(ft (rav-get _rav)
  (rav-get _rav _var))



; constraint var declaration (and restriciton)
; --------------------------------------------
;
; "fd" can be used to create a new constraint var or to restrict a
; previously defined one:
;
; (_x : `(fd (tup 1 2 3) x)) ; creates _x
; ...
; (_x : `(fd (tup 1 3 5))) ; restricts _x


(hn (fd-var _fd _dom _const) ; create new dom var
  (var _fd)
  (rav-set _rav-dom _dom)
  (is _fd `(:fd _rav-dom _const)))

(hn (fd-var _fd _dom _const) ; restrict dom var
  (nonvar _fd)
  (is _fd `(:fd _rav-dom _const))
  (is _inter (non-empty-set (set-intersec (rav-get _rav-dom _next) _dom)))
  (rav-set* _next _inter))


(hn ((fd _dom _const) _fd) ; for use in type decls (declaration)
  (fd-var _fd _dom _const))

(hn ((fd _dom) _fd) ; for use in type decls (restriction)
  (fd-var _fd _dom id))


; equality constraint
; -------------------

(hn (fd= (:fd _dv1 id) (:fd _dv2 id)) ; (does not check _const !)
  (is _d1 (rav-get _dv1 _v1))
  (is _d2 (rav-get _dv2 _v2))
  (is _inter (set-intersec _d1 _d2))
  (rav-set** _v1 _inter _next) ; _next : "synchronize" both dom vars
  (rav-set** _v2 _inter _next))


; inequality constraint
; ---------------------

(hn (fd/= (:fd _dv1 id) (:fd _dv2 id))
  (is _d1 (rav-get _dv1 _v1))
  (is _d2 (rav-get _dv2 _v2))
  (is _inter (set-intersec _d1 _d2))
  (fd/=2 _d1 _d2 _v1 _v2 _inter))

(hn (fd/=2 _d1 _d2 id id (tup))) ; intersection empty -> nothing to do

(hn (fd/=2 _d1 _d2 _v1 _v2 _inter) 
  (is _inter `(tup id | id)) ; nonempty intersection
  (is _d1-rest (set-diff _d1 _inter))
  (is _d2-rest (set-diff _d2 _inter))
  (all-/=-possibilities _d1-rest _d2-rest _inter _s1 _s2)
  (rav-set* _v1 _s1)
  (rav-set* _v2 _s2))

(hn (all-/=-possibilities _s1 _s2 _inter _ns1 _s2)
  (non-empty-set _s2)
  (is _ns1 (appfun _inter _s1)))
(hn (all-/=-possibilities _s1 _s2 _inter _s1 _ns2)
  (non-empty-set _s1)
  (is _ns2 (appfun _inter _s2)))
(hn (all-/=-possibilities _s1 _s2 _inter _ns1 _ns2)
  (fd-split _inter _x _rest)
  (is _ns1 `(tup _x | _s1))
  (is _ns2 (non-empty-set (appfun _rest _s2))))

(hn (fd-split _set _x _rest)
  (member _x _set)
  (is _rest (set-diff _set `(tup _x))))

(ft (non-empty-set _x)
  (is _x `(tup id | id)))


; fd auxiliaries
; --------------

(hn (fd-print (:fd _fd _const))
  (rf-princ _const)
  (rf-princ \ \=\ )
  (rf-princ (rav-get _fd))
  (rf-terpri))


(hn (fd-single-solution (:fd _fd id)) ; restricts constr. var to one solution
  (is _set (rav-get _fd _v))
  (fd-ss2 _set _v))

(hn (fd-ss2 (tup _x) id))
(hn (fd-ss2 _set _v)
  (is (tup id id | id) _set) ; more than one element
  (member _x _set)
  (rav-set* _v `(tup _x)))


(hn (fd-single-solutions (tup))) ; same for a list of constr. vars
(hn (fd-single-solutions (tup _cv | _rest))
  (fd-single-solution _cv)
  (fd-single-solutions _rest))

(hn (fd-sprint (:fd _fd _const)) ; prints single solution of a constr.  var
  (is (tup _x) (rav-get _fd))    ; (generated by single-solution[s])
  (rf-princ _const)
  (rf-princ \ \=\ )
  (rf-princ _x)
  (rf-terpri))



; auxiliary operators
; -------------------


(ft (set-intersec _x _y)
  (once `(set-intersec2 _x _y)))

(ft (set-intersec2 (tup) _s2) `(tup))

(ft (set-intersec2 (tup _x | _rest) _s2)
  (member _x _s2)
  (tup _x | (set-intersec2 _rest _s2)))

(ft (set-intersec2 (tup _x | _rest) _s2)
  (set-intersec2 _rest _s2))


(ft (set-diff _x _y)
  (once `(set-diff2 _x _y)))

(ft (set-diff2 (tup) _s2) `(tup))

(ft (set-diff2 (tup _x | _rest) _s2)
  (member _x _s2)
  (set-diff2 _rest _s2))

(ft (set-diff2 (tup _x | _rest) _s2)
  (tup _x | (set-diff2 _rest _s2)))


(ft (appfun (tup) _l) _l)
(ft (appfun (tup _h | _r) _l) (tup _h | (appfun _r _l)))


(ft (rf-length (tup)) 0)
(ft (rf-length (tup id | _rest))
  (1+ (rf-length _rest)))


; Arbitrary Constraints via a HO Constraint Function
; --------------------------------------------------


(hn ((fd-constr _constr) (:fd _dv1 _c1) (:fd _dv2 _c2))
  (is _s1 (rav-get _dv1 _v1))
  (is _s2 (rav-get _dv2 _v2))
  (fd-constr1 _constr _s1 _s2 _c1 _c2 _v1 _v2))

(hn (fd-constr1 _constr _s1 _s2 _c1 _c2 _v1 _v2)
  (is _l1 (rf-length _s1))
  (is _l2 (rf-length _s2))
  (fd-constr2 _constr _s1 _s2 _c1 _c2 _v1 _v2 _l1 _l2))

(hn (fd-constr2 _constr _s1 _s2 _c1 _c2 _v1 _v2 _l1 _l2)
  (<= _l1 _l2)
  (fd-constr3 _constr norm _s1 _s2 _c1 _c2 _v1 _v2))

(hn (fd-constr2 _constr _s1 _s2 _c1 _c2 _v1 _v2 _l1 _l2)
  (> _l1 _l2)
  (fd-constr3 _constr rev _s2 _s1 _c2 _c1 _v2 _v1))

(hn (fd-constr3 _constr _dir _s1 _s2 _c1 _c2 _v1 _v2)
  (member _x _s1)
  (is _allowed-s2-values 
      (non-empty-set (once `(allowed-values1 _constr _dir _x _c1 _s2 _c2))))
  (rav-set* _v1
	    (once `(allowed-values2 _constr _dir _x _s1 _c1 
				    _allowed-s2-values _c2)))
  (rav-set* _v2 _allowed-s2-values))

; (allowed-values1 _constr _dir _x _c1 _s2 _c2) : return subset _s of _s2
; with (_constr _x _y) for all _y in _s     for _dir = norm
;   or (_constr _y _x) for all _y in _s     for _dir = rev

(ft (allowed-values1 _constr _dir _x _c1 (tup) _c2)
  `(tup))
(ft (allowed-values1 _constr norm _x _c1 (tup _y | _rest) _c2)
  (_constr _x _c1 _y _c2)
  (tup _y | (allowed-values1 _constr norm _x _c1 _rest _c2)))
(ft (allowed-values1 _constr rev _x _c1 (tup _y | _rest) _c2)
  (_constr _y _c2 _x _c1)
  (tup _y | (allowed-values1 _constr rev _x _c1 _rest _c2)))
(ft (allowed-values1 _constr _dir _x _c1 (tup _y | _rest) _c2)
  (allowed-values1 _constr _dir _x _c1 _rest _c2))


; (allowed-values2 _constr _dir _x _s1 _c1 _s2 _c2) : return subset _s of _s1
; with (_constr _x _y) for all _x in _s and _y in _s2    for _dir = norm
;   or (_constr _y _x) for all _x in _s and _y in _s2    for _dir = rev
; (_x is already known to be in _s)

(ft (allowed-values2 _constr _dir _x (tup) _c1 _s2 _c2) `(tup))
(ft (allowed-values2 _constr _dir _x (tup _x | _rest) _c1 _s2 _c2)
  (tup _x | (allowed-values2 _constr _dir _x _rest _c1 _s2 _c2)))
(ft (allowed-values2 _constr _dir _x (tup _y | _rest) _c1 _s2 _c2)
  (once `(check-constraint _constr _dir _y _c1 _s2 _c2))
  (tup _y | (allowed-values2 _constr _dir _x _rest _c1 _s2 _c2)))
(ft (allowed-values2 _constr _dir _x (tup _y | _rest) _c1 _s2 _c2)
  (allowed-values2 _constr _dir _x _rest _c1 _s2 _c2))

; (check-constraint _constr _dir _y _c1 _s2 _c2):
; check if (_constr _y _c1 _z _c2) for all _z in _s2   for _dir = norm
;       or (_constr _z _c2 _y _c1) for all _z in _s2   for _dir = rev

(hn (check-constraint _constr _dir _y _c1 (tup) _c2))
(hn (check-constraint _constr norm _y _c1 (tup _z | _rest) _c2)
  (_constr _y _c1 _z _c2)
  (check-constraint _constr norm _y _c1 _rest _c2))
(hn (check-constraint _constr rev _y _c1 (tup _z | _rest) _c2)
  (_constr _z _c2 _y _c1)
  (check-constraint _constr rev _y _c1 _rest _c2))

